\chapter{Graphs}

\section{DSU}
	\kactlimport{DSU/DSU (7.6).h}
	\kactlimport{DSU/ManhattanMST.h}

\section{Trees}
	\kactlimport{Trees (10)/LCAjump (10.2).h}
	\kactlimport{Trees (10)/Centroid (10.3).h}
	\kactlimport{Trees (10)/HLD (10.3).h}

	\subsection{SqrtDecompton}

		HLD generally suffices. If not, here are some common strategies:
		
		\begin{itemize}
			\item Rebuild the tree after every $\sqrt N$ queries. % https://codeforces.com/contest/1254/submission/65439802
			\item Consider vertices with $>$ or $<\sqrt N$ degree separately. % https://codeforces.com/contest/1254/submission/65437007
			\item For subtree updates, note that there are $O(\sqrt N)$ distinct sizes among child subtrees of any node.
		\end{itemize}

		\textbf{Block Tree:} Use a DFS to split edges into contiguous groups of size $\sqrt N$ to $2\sqrt N.$

		\textbf{Mo's Algorithm for Tree Paths:} Maintain an array of vertices where each one appears twice, once when a DFS enters the vertex (\texttt{st}) and one when the DFS exists (\texttt{en}). For a tree path $u\leftrightarrow v$ such that \texttt{st[u]<st[v]},

		\begin{itemize}
		\item If $u$ is an ancestor of $v,$ query \texttt{[st[u],st[v]]}.
		\item Otherwise, query $\texttt{[en[u],st[v]]}$ and consider $LCA(u,v)$ separately.
		\end{itemize}

\section{DFS Algorithms}
	\kactlimport{DFS/SCC (12.1).h}
	\kactlimport{DFS/2SAT (12.1).h}
	\kactlimport{DFS/EulerPath (12.2).h}
	\kactlimport{DFS/BCC (12.4).h}

\section{Flows \& Matching}

	\textbf{Konig's Theorem:} In a bipartite graph, max matching = min vertex cover.

	\textbf{Dilworth's Theorem:} For any partially ordered set, the sizes of the largest antichain and of the smallest chain decomposition are equal. Equivalent to Konig's theorem on the bipartite graph $(U,V,E)$ where $U=V=S$ and $(u,v)$ is an edge when $u<v.$ % Wikipedia, https://codeforces.com/gym/102428/problem/A

	\kactlimport{Flows (12.3)/Dinic.h}
	\kactlimport{Flows (12.3)/MCMF.h}
	\kactlimport{Flows (12.3)/GomoryHu.h}
	\kactlimport{Matching/DFSmatch.h}
	\kactlimport{Matching/Hungarian.h}
	\kactlimport{Matching/UnweightedMatch.h}

\section{Misc}
	\kactlimport{Misc/MaximalCliques.h}
	\kactlimport{Misc/LCT.h}
	\kactlimport{Misc/DirectedMST.h}
	\kactlimport{Misc/DominatorTree.h}
	\kactlimport{Misc/EdgeColor.h}
